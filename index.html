<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Doggocam</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style></style>
  </head>
  <body>
    <header><h1>Doggocam</h1></header>
    <section>
      <h2>Config</h2>
      <select id="target_source">
        <option>Loading Sources...</option>
      </select>
    </section>
    <section>
      <h2>Command Logs</h2>
      <ul id="command_log"></ul>
    </section>
    <section>
      <h2>Channel List</h2>
    </section>
    <script type="application/javascript" src="./tmi.min.js"></script>
    <script
      type="application/javascript"
      src="https://unpkg.com/obs-websocket-js@4.0.3/dist/obs-websocket.js"
    ></script>
    <script type="application/javascript">
      function authAndConnect() {
        // build the auth uri
        const commands = {
          '!doggocam': { duration: 5, requireMod: false },
          '!doggocam15': { duration: 15, requireMod: true },
        };
        const clientId = 'd3musw66rb3uibj08g4prkq3kw8ist';
        const redirectUri = 'https://pxslip.github.io/doggocam';
        const responseType = encodeURIComponent('token id_token');
        const scope = encodeURIComponent('chat:read openid');
        const claims = encodeURIComponent(
          '{id_token: {preferred_username: null}}'
        );
        const twitchAuthUrl = `https://id.twitch.tv/oauth2/authorize?client_id=${clientId}&redirect_uri=${redirectUri}&response_type=${responseType}&scope=${scope}&claims=${claims}`;
        // check if there is a twitch token in the url
        const fragment = window.location.hash.substr(1);
        const data = fragment.split('&');
        let idToken = '';
        let accessToken = '';
        let username = '';
        for (frag of data) {
          const [key, value] = frag.split('=');
          if (key === 'id_token') {
            idToken = value;
          } else if (key === 'access_token') {
            accessToken = value;
          }
        }
        if (!idToken && !accessToken) {
          // check localStorage for the token/username
          accessToken = localStorage.getItem('doggocam_accessToken');
          username = localStorage.getItem('doggocam_username');
          if (!accessToken && !username) {
            // redirect to twitch auth
            // window.location.href = twitchAuthUrl;
            return;
          }
        } else {
          // we have an access token and JWT, get the username and shove both in localStorage
          const jwt = JSON.parse(atob(idToken.split('.')[1]));
          username = jwt.preferred_username;
          localStorage.setItem('doggocam_accessToken', accessToken);
          localStorage.setItem('doggocam_username', username);
        }
        // connect to obs
        const obs = new OBSWebSocket();
        obs.connect({
          address: 'localhost:4444',
          password: '',
          reconnect: true,
        });
        // get the list of scenes, and sources within them
        const scenes = obs.send('GetSceneList');
        const sources = [];
        scenes.forEach((scene) => {
          sources.push(...scene.sources);
        });
        // wire up a listener to store the selected source in localStorage for repeat visits
        const targetSourceList = document.getElementById('target_source');
        targetSourceList.addEventListener('change', (e) => {
          localStorage.setItem('doggocam_targetSource', e.target.value);
        });
        const targetSource = localStorage.getItem('doggocam_targetSource');
        sources.forEach((source) => {
          const opt = document.createElement('option');
          option.value = source.name;
          option.innerText = source.name;
          if (source.name === targetSource) {
            option.selected = true;
          }
        });
        // if there is a token, connect to twitch
        const client = new tmi.client({
          connection: {
            secure: true,
            reconnect: true,
          },
          identity: {
            username: username,
            password: accessToken,
          },
          channels: [`#${username}`],
        });
        client.connect();
        let sourceActive = false;
        let timeOutId = null;
        client.on('message', (channel, userstate, message, self) => {
          if (self) {
            return;
          }
          const command = message.split(' ')[0];
          if (
            command.startWith('!') &&
            Object.keys(commands).includes(command)
          ) {
            const commandData = commands[command];
            if (commandData.requireMod && !userstate.mod) {
              return;
            }
            if (!sourceActive) {
              obs.send('SetSceneItemProperties', {
                item: {
                  name: targetSource,
                },
                visible: true,
              });
            }
            if (timeOutId) {
              clearTimeout(timeOutId);
            }
            timeOutId = setTimeout(() => {
              obs.send('SetSceneItemProperties', {
                item: {
                  name: targetSource,
                },
                visible: false,
              });
              sourceActive = false;
            }, commandData.duration * 1000);
          }
        });
      }

      authAndConnect();
    </script>
  </body>
</html>
